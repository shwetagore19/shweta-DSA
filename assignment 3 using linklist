#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// Node structure for stack (linked list)
struct Node {
    char data;
    struct Node *next;
};

// Function to create a new node
struct Node* newNode(char data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->next = NULL;
    return node;
}

// Push onto stack
void push(struct Node** top, char data) {
    struct Node* node = newNode(data);
    node->next = *top;
    *top = node;
}

// Pop from stack
char pop(struct Node** top) {
    if (*top == NULL)
        return '\0'; // stack empty
    struct Node* temp = *top;
    char popped = temp->data;
    *top = (*top)->next;
    free(temp);
    return popped;
}

// Peek top element
char peek(struct Node* top) {
    if (top == NULL)
        return '\0';
    return top->data;
}

// Check if stack is empty
int isEmpty(struct Node* top) {
    return top == NULL;
}

// Operator precedence
int prec(char c) {
    if (c == '^')
        return 3;
    else if (c == '/' || c == '*')
        return 2;
    else if (c == '+' || c == '-')
        return 1;
    else
        return -1;
}

// Infix to Postfix conversion
void infixToPostfix(char *exp) {
    int len = strlen(exp);
    char result[len + 1];   // result array
    int j = 0;
    struct Node* stack = NULL; // stack top pointer

    for (int i = 0; i < len; i++) {
        char c = exp[i];

        // If the character is an operand, add to result
        if (isalnum(c))
            result[j++] = c;

        // If it is an opening parenthesis, push to stack
        else if (c == '(')
            push(&stack, '(');

        // If it is a closing parenthesis, pop until '('
        else if (c == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                result[j++] = pop(&stack);
            }
            pop(&stack); // remove '('
        }

        // Operator encountered
        else {
            while (!isEmpty(stack) &&
                   (prec(c) < prec(peek(stack)) ||
                   (prec(c) == prec(peek(stack)) && c != '^'))) {
                result[j++] = pop(&stack);
            }
            push(&stack, c);
        }
    }

    // Pop remaining operators
    while (!isEmpty(stack)) {
        result[j++] = pop(&stack);
    }

    result[j] = '\0';  // null terminate
    printf("%s\n", result);
}

// Driver
int main() {
    char exp[] = "a+b*(c^d-e)^(f+g*h)";
    infixToPostfix(exp);  // do the conversion and print
    return 0;
}
